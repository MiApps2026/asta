<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Generador de Discusiones Científicas - Gemini + ASTA</title>
    <!-- Tailwind CSS para diseño -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Marked.js para renderizar Markdown -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <!-- Iconos Lucide -->
    <script src="https://unpkg.com/lucide@latest"></script>
    
    <style>
        .prose h1, .prose h2, .prose h3 { color: #1e293b; font-weight: 600; margin-top: 1.5em; margin-bottom: 0.5em; }
        .prose p { margin-bottom: 1em; line-height: 1.7; color: #334155; }
        .prose ul { list-style-type: disc; padding-left: 1.5em; margin-bottom: 1em; }
        .prose strong { color: #0f172a; }
        .loader { border: 4px solid #f3f3f3; border-top: 4px solid #8b5cf6; border-radius: 50%; width: 24px; height: 24px; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body class="bg-slate-50 min-h-screen text-slate-800 font-sans">

    <main class="max-w-4xl mx-auto p-4 md:p-8">
        <!-- Cabecera -->
        <header class="mb-8 text-center">
            <h1 class="text-3xl font-bold text-slate-900 flex items-center justify-center gap-2">
                <i data-lucide="microscope" class="text-purple-600"></i> Discusión Científica IA
            </h1>
            <p class="text-slate-500 mt-2">Impulsado por Gemini 2.5 Flash y ASTA Snippet Search</p>
        </header>

        <!-- Panel de Configuración -->
        <div class="bg-white p-6 rounded-xl shadow-sm border border-slate-200 mb-6">
            <h2 class="text-sm font-semibold text-slate-700 uppercase tracking-wider mb-4 flex items-center gap-2">
                <i data-lucide="key" class="w-4 h-4 text-purple-600"></i> Configuración de APIs (Local)
            </h2>
            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
                <div>
                    <label class="block text-sm font-medium text-slate-700 mb-1">ASTA Endpoint <span class="text-red-500">*</span></label>
                    <input type="text" id="asta-endpoint" class="w-full p-2 border border-slate-300 rounded-lg focus:ring-2 focus:ring-purple-500 outline-none text-sm" value="https://asta-tools.allen.ai/mcp/v1">
                </div>
                <div>
                    <label class="block text-sm font-medium text-slate-700 mb-1">ASTA API Key <span class="text-red-500">*</span></label>
                    <input type="password" id="asta-key" class="w-full p-2 border border-slate-300 rounded-lg focus:ring-2 focus:ring-purple-500 outline-none" placeholder="Clave de AllenAI">
                </div>
                <div>
                    <label class="block text-sm font-medium text-slate-700 mb-1">Gemini API Key <span class="text-red-500">*</span></label>
                    <input type="password" id="gemini-key" class="w-full p-2 border border-slate-300 rounded-lg focus:ring-2 focus:ring-purple-500 outline-none" placeholder="AIzaSy...">
                </div>
                <div>
                    <label class="block text-sm font-medium text-slate-700 mb-1">Semantic Scholar (Opcional)</label>
                    <input type="password" id="scholar-key" class="w-full p-2 border border-slate-300 rounded-lg focus:ring-2 focus:ring-purple-500 outline-none" placeholder="Respaldo">
                </div>
            </div>
            <p class="text-xs text-slate-400 mt-3">Tus claves se guardan localmente en tu navegador. Nunca se envían a servidores externos ajenos a Google o AllenAI.</p>
        </div>

        <!-- Panel de Búsqueda -->
        <div class="bg-white p-6 rounded-xl shadow-sm border border-slate-200 mb-6 relative">
            <label class="block text-lg font-medium text-slate-800 mb-2">Tema de la Discusión:</label>
            <textarea id="user-query" rows="3" class="w-full p-3 border border-slate-300 rounded-lg focus:ring-2 focus:ring-purple-500 outline-none transition resize-none text-lg" placeholder="Ej: Mecanismos fisiológicos del ayuno intermitente en la resistencia a la insulina..."></textarea>
            
            <div class="mt-4 flex justify-between items-center">
                <span id="status-text" class="text-sm font-medium text-purple-600 hidden flex items-center gap-2">
                    <div class="loader"></div> <span id="status-message">Conectando...</span>
                </span>
                <button id="generate-btn" class="ml-auto bg-purple-600 hover:bg-purple-700 text-white px-6 py-2 rounded-lg font-medium transition shadow-sm flex items-center gap-2">
                    <i data-lucide="sparkles" class="w-4 h-4"></i> Generar Discusión
                </button>
            </div>
        </div>

        <!-- Resultados -->
        <div id="result-container" class="bg-white p-6 md:p-8 rounded-xl shadow-sm border border-slate-200 hidden">
            <div class="flex items-center gap-2 mb-6 border-b border-slate-100 pb-4">
                <i data-lucide="file-text" class="text-purple-600"></i>
                <h2 class="text-xl font-semibold text-slate-800">Discusión Generada</h2>
                <button id="copy-btn" class="ml-auto p-2 text-slate-400 hover:text-purple-600 transition" title="Copiar al portapapeles">
                    <i data-lucide="copy" class="w-5 h-5"></i>
                </button>
            </div>
            
            <div id="references-used" class="mb-6 p-4 bg-purple-50 rounded-lg border border-purple-100 text-sm hidden">
                <h3 class="font-semibold text-purple-800 mb-2 flex items-center gap-1">
                    <i data-lucide="database" class="w-4 h-4"></i> Snippets Recuperados de ASTA:
                </h3>
                <ul id="papers-list" class="list-disc pl-5 space-y-1 text-slate-700"></ul>
            </div>

            <div id="markdown-output" class="prose max-w-none"></div>
        </div>

        <!-- Consola de Depuración -->
        <div class="mt-8 bg-slate-900 rounded-xl overflow-hidden shadow-sm border border-slate-700">
            <div class="bg-slate-800 px-4 py-2 flex justify-between items-center border-b border-slate-700">
                <span class="text-slate-300 text-sm font-semibold flex items-center gap-2">
                    <i data-lucide="terminal" class="w-4 h-4"></i> Consola de Depuración (Logs y JSON)
                </span>
                <button id="clear-console" class="text-slate-400 hover:text-white text-xs transition">Limpiar</button>
            </div>
            <div id="console-output" class="p-4 h-80 overflow-y-auto text-green-400 font-mono text-xs whitespace-pre-wrap break-words"></div>
        </div>
    </main>

    <script>
        lucide.createIcons();

        // Función de logging para la consola UI
        function log(message, data = null) {
            const consoleOutput = document.getElementById('console-output');
            const timestamp = new Date().toLocaleTimeString();
            let logText = `[${timestamp}] ${message}\n`;
            if (data) {
                logText += JSON.stringify(data, null, 2) + '\n';
            }
            logText += '----------------------------------------\n';
            consoleOutput.textContent += logText;
            consoleOutput.scrollTop = consoleOutput.scrollHeight;
        }

        // Referencias DOM
        const btnGenerate = document.getElementById('generate-btn');
        const statusText = document.getElementById('status-text');
        const statusMessage = document.getElementById('status-message');
        const resultContainer = document.getElementById('result-container');
        const markdownOutput = document.getElementById('markdown-output');
        const referencesUsed = document.getElementById('references-used');
        const papersList = document.getElementById('papers-list');
        const copyBtn = document.getElementById('copy-btn');

        // Cargar claves previas
        document.addEventListener('DOMContentLoaded', () => {
            if(localStorage.getItem('gemini_key')) document.getElementById('gemini-key').value = localStorage.getItem('gemini_key');
            if(localStorage.getItem('asta_key')) document.getElementById('asta-key').value = localStorage.getItem('asta_key');
            if(localStorage.getItem('asta_endpoint')) document.getElementById('asta-endpoint').value = localStorage.getItem('asta_endpoint');
        });

        // Limpiar consola
        document.getElementById('clear-console').addEventListener('click', () => {
            document.getElementById('console-output').textContent = '';
        });

        // Botón copiar
        copyBtn.addEventListener('click', () => {
            // navigator.clipboard is not reliable in iframes, using fallback
            const textArea = document.createElement("textarea");
            textArea.value = markdownOutput.innerText;
            document.body.appendChild(textArea);
            textArea.select();
            try {
                document.execCommand('copy');
                alert("¡Texto copiado al portapapeles!");
            } catch (err) {
                console.error('Failed to copy', err);
            }
            document.body.removeChild(textArea);
        });

        // Evento principal
        btnGenerate.addEventListener('click', async () => {
            const geminiKey = document.getElementById('gemini-key').value.trim();
            const astaKey = document.getElementById('asta-key').value.trim();
            const astaEndpoint = document.getElementById('asta-endpoint').value.trim();
            const query = document.getElementById('user-query').value.trim();

            if (!geminiKey || !astaKey || !query || !astaEndpoint) {
                alert("Por favor, introduce las API Keys, el Endpoint y el tema a buscar.");
                return;
            }

            localStorage.setItem('gemini_key', geminiKey);
            localStorage.setItem('asta_key', astaKey);
            localStorage.setItem('asta_endpoint', astaEndpoint);

            // UI State
            btnGenerate.disabled = true;
            btnGenerate.classList.add('opacity-50', 'cursor-not-allowed');
            statusText.classList.remove('hidden');
            resultContainer.classList.add('hidden');
            papersList.innerHTML = '';
            referencesUsed.classList.add('hidden');
            
            log(`INICIO DE FLUJO: Nueva consulta iniciada`, { query });

            try {
                await runGeminiWorkflow(query, geminiKey, astaKey, astaEndpoint);
            } catch (error) {
                console.error(error);
                log(`ERROR CRÍTICO: ${error.message}`);
                alert("Error: " + error.message);
            } finally {
                btnGenerate.disabled = false;
                btnGenerate.classList.remove('opacity-50', 'cursor-not-allowed');
                statusText.classList.add('hidden');
            }
        });

        /**
         * Petición REAL a la API ASTA usando protocolo MCP sobre HTTP (SSE + JSON-RPC)
         */
        async function fetchASTASnippets(functionArgs, astaKey, astaEndpoint) {
            statusMessage.innerText = `Conectando al servidor MCP de ASTA...`;
            log(`INICIANDO PROTOCOLO MCP: Conectando a ${astaEndpoint}`);

            let postEndpointUrl = null;

            try {
                // PASO 1: Iniciar conexión SSE para recibir el endpoint de trabajo
                const sseResponse = await fetch(astaEndpoint, {
                    method: 'GET',
                    headers: {
                        'x-api-key': astaKey,
                        'Accept': 'text/event-stream'
                    }
                });

                if (!sseResponse.ok) throw new Error(`Handshake MCP falló con estado ${sseResponse.status}`);

                // Leer el stream de eventos
                const reader = sseResponse.body.getReader();
                const decoder = new TextDecoder();
                let buffer = '';
                let currentEvent = null;

                while (true) {
                    const { value, done } = await reader.read();
                    if (done) break;
                    buffer += decoder.decode(value, { stream: true });
                    
                    const lines = buffer.split(/\r?\n/);
                    for (let i = 0; i < lines.length; i++) {
                        if (lines[i].startsWith('event:')) {
                            currentEvent = lines[i].split(':')[1].trim();
                        } else if (lines[i].startsWith('data:') && currentEvent === 'endpoint') {
                            const relativeEndpoint = lines[i].substring(5).trim();
                            postEndpointUrl = new URL(relativeEndpoint, astaEndpoint).toString();
                            break;
                        }
                    }
                    if (postEndpointUrl) {
                        reader.cancel(); // Ya tenemos la URL, cerramos el stream
                        break;
                    }
                }
            } catch (networkError) {
                log(`NETWORK ERROR (CORS o Handshake MCP fallido):`, networkError.message);
                throw new Error("Fallo de conexión MCP con ASTA. RECUERDA: Al estar ejecutando esto en un navegador (HTML local), AllenAI podría estar bloqueándote por CORS. Por favor, instala y activa una extensión 'Allow CORS' en tu navegador.");
            }

            if (!postEndpointUrl) {
                throw new Error("No se pudo obtener el POST endpoint del servidor MCP.");
            }

            log(`MCP HANDSHAKE OK. URL de trabajo recibida:`, postEndpointUrl);
            statusMessage.innerText = `Ejecutando snippet_search...`;

            // PASO 2: Enviar el comando JSON-RPC al endpoint recibido
            const rpcPayload = {
                jsonrpc: "2.0",
                id: 1,
                method: "tools/call",
                params: {
                    name: "snippet_search",
                    arguments: functionArgs
                }
            };

            log(`ENVIANDO ORDEN A ASTA (JSON-RPC):`, rpcPayload);

            const callResponse = await fetch(postEndpointUrl, {
                method: 'POST',
                headers: {
                    'x-api-key': astaKey,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(rpcPayload)
            });

            if (!callResponse.ok) {
                const errorText = await callResponse.text();
                log(`ASTA MCP ERROR: Code ${callResponse.status}`, errorText);
                throw new Error(`Error llamando a la herramienta MCP: ${callResponse.status} - ${errorText}`);
            }

            const data = await callResponse.json();
            log(`ASTA MCP RESPONSE: JSON Recibido`, data);
            
            // PASO 3: Mostrar los resultados en la interfaz
            referencesUsed.classList.remove('hidden');
            let snippetsArray = [];
            
            // Extraer el contenido de la respuesta MCP (suele venir anidado)
            if (data.result && data.result.content && data.result.content.length > 0) {
                try {
                    // El estándar MCP dice que las tools devuelven texto crudo
                    const textData = data.result.content[0].text;
                    const parsedData = JSON.parse(textData);
                    snippetsArray = parsedData.results || parsedData.snippets || parsedData;
                } catch (e) {
                    snippetsArray = [{ title: "Resultados Crudos MCP", body_snippet: data.result.content[0].text }];
                }
            } else {
                snippetsArray = data.result || [];
            }
            
            if (!Array.isArray(snippetsArray) || snippetsArray.length === 0) {
                log("ASTA: No se encontraron snippets para esa query.");
                const li = document.createElement('li');
                li.innerText = "No se encontraron papers relevantes en ASTA.";
                papersList.appendChild(li);
                return data;
            }

            snippetsArray.forEach(snippet => {
                const li = document.createElement('li');
                li.innerHTML = `<strong>${snippet.title || 'Paper sin título'}</strong> (${snippet.year || 'N/A'}) - DOI: ${snippet.doi || snippet.paper_id || 'N/A'}`;
                papersList.appendChild(li);
            });

            return data; // Se lo devolvemos a Gemini intacto
        }

        /**
         * Bucle del Orquestador (Function Calling) usando la API REST de Gemini
         */
        async function runGeminiWorkflow(userQuery, geminiKey, astaKey, astaEndpoint) {
            statusMessage.innerText = "Iniciando Gemini 2.5 Flash...";
            // Usamos la API de Gemini
            const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent?key=${geminiKey}`;

            const systemPrompt = "Eres un investigador académico de alto nivel. Tu objetivo es redactar una discusión rigurosa basada en literatura científica real. DEBES usar la herramienta 'snippet_search' para recuperar extractos de papers. REGLA OBLIGATORIA: Al redactar, debes citar todas las afirmaciones usando estrictamente el formato '(Autor principal, Año, DOI)' basado en la información devuelta por la herramienta. Incluye una sección final de Referencias.";

            // 1. Declaración de la herramienta según la especificación exacta
            const tools = [{
                functionDeclarations: [{
                    name: "snippet_search",
                    description: "Search for text snippets that most closely match the query. Excerpts of approx 500 words drawn from paper title, abstract, and body.",
                    parameters: {
                        type: "OBJECT",
                        properties: {
                            query: { type: "STRING", description: "The query to search for." },
                            limit: { type: "INTEGER", description: "The number of snippets to return. Default 5." },
                            venues: { type: "STRING", description: "Comma-separated venues, e.g. 'Nature,N. Engl. J. Med.'" },
                            paper_ids: { type: "STRING", description: "Comma-separated list of IDs like DOI:10... or PMID:123..." }
                        },
                        required: ["query"]
                    }
                }]
            }];

            let contents = [
                { role: "user", parts: [{ text: userQuery }] }
            ];

            const requestBody = {
                systemInstruction: { parts: [{ text: systemPrompt }] },
                tools: tools,
                contents: contents
            };

            log(`GEMINI REQUEST (Ronda 1): Solicitando evaluación del LLM`, requestBody);

            // Ronda 1: Solicitar a Gemini
            let response = await fetch(url, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(requestBody)
            });

            if(!response.ok) {
                const err = await response.text();
                log(`GEMINI ERROR (Ronda 1):`, err);
                throw new Error("Fallo en la API de Gemini. Revisa tu API Key.");
            }
            
            let data = await response.json();
            log(`GEMINI RESPONSE (Ronda 1): Respuesta recibida`, data);
            
            let responsePart = data.candidates[0].content.parts[0];

            // 2. Interceptar: ¿La IA quiere usar la herramienta?
            if (responsePart.functionCall) {
                const functionName = responsePart.functionCall.name;
                const functionArgs = responsePart.functionCall.args;
                
                log(`HERRAMIENTA SOLICITADA POR IA: ${functionName}`, functionArgs);

                if (functionName === "snippet_search") {
                    // Actualizar el historial con la petición del modelo
                    contents.push({ role: "model", parts: [responsePart] });

                    // Ejecutar nuestra función externa (ASTA)
                    const searchResults = await fetchASTASnippets(functionArgs, astaKey, astaEndpoint);
                    
                    statusMessage.innerText = "Redactando síntesis y citas...";

                    // Proveer los resultados a la IA
                    const toolResponseContent = {
                        role: "user", 
                        parts: [{
                            functionResponse: {
                                name: "snippet_search",
                                response: { results: searchResults }
                            }
                        }]
                    };
                    contents.push(toolResponseContent);

                    // Ronda 2: Llamada final para que redacte
                    const finalRequest = {
                        systemInstruction: { parts: [{ text: systemPrompt }] },
                        tools: tools,
                        contents: contents
                    };
                    
                    log(`GEMINI REQUEST (Ronda 2): Enviando resultados de ASTA para redactar`, finalRequest);

                    const finalResponse = await fetch(url, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(finalRequest)
                    });

                    if(!finalResponse.ok) {
                        const err = await finalResponse.text();
                        log(`GEMINI ERROR (Ronda 2):`, err);
                        throw new Error("Fallo en la API de Gemini al redactar.");
                    }

                    const finalData = await finalResponse.json();
                    log(`GEMINI FINAL RESPONSE: Redacción completada`, finalData);
                    
                    const finalMarkdown = finalData.candidates[0].content.parts[0].text;
                    
                    renderResult(finalMarkdown);
                    log(`FLUJO COMPLETADO CON ÉXITO.`);
                }
            } else {
                // Si la IA decidió no usar la herramienta
                log(`GEMINI DECISIÓN: No se solicitó ninguna herramienta. Renderizando texto directo.`);
                renderResult(responsePart.text);
            }
        }

        function renderResult(markdownText) {
            resultContainer.classList.remove('hidden');
            markdownOutput.innerHTML = marked.parse(markdownText);
        }
    </script>
</body>
</html>